---
title: "Statistical Package for Queueing in R"
subtitle: Angyalka Valcsics, Pearl Armstrong, Shawn Houser
author: "University of Southern Maine"
date: "12/7/2021"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- https://htmlpreview.github.io/?https://github.com/angyalkavalcsics/QueueingNetworks/blob/main/QueueingNetworks.html -->

This package was created as a graduate project for a course in Queueing Theory and we dedicate it to Professor Muhammad El-Taha.

## How To Install

- To install a package from Github for the first time, first install the devtools package. This can be downloaded from the CRAN.
```{r install1, eval = FALSE}
install.packages("devtools", repos = "http://cran.us.r-project.org")
```
- Load the devtools package.
```{r install2, eval = FALSE}
library(devtools)
```
- Download the package from GitHub.
```{r install3, eval = FALSE}
install_github("angyalkavalcsics/QueueingNetworks/QinR")
```
- Load the package to use the functions.
```{r install4}
library (QinR)	
```
```{r printhelp, echo = FALSE}

help_console <- function(topic, package,
                         format=c("text", "html", "latex", "Rd"),
                         before=NULL, after=NULL) {
  # topic - the command for which help is required
  # package - the package name with the required topic
  # format - output format
  # before - place code before the output e.g. "<blockquote>"
  # after - place code after the output e.g. "</blockquote>"

  # based on code by Noam Ross
  #  http://www.noamross.net/archives/2013-06-18-helpconsoleexample/
  # Stéphane Laurent
  #  https://stackoverflow.com/questions/60468080/
  #   print-an-r-help-file-vignette-as-output-into-an-r-html-notebook
  # and Michael Sumner (mdsumner)
  #  https://stackoverflow.com/questions/7495685/
  #   how-to-access-the-help-documentation-rd-source-files-in-r

  format <- match.arg(format)
  if (!is.character(topic)) topic <- deparse(substitute(topic))
  db <- tools::Rd_db(package)
  helpfile <- db[paste0(topic, ".Rd")][[1]]

  hs <- capture.output(
    switch(
      format,
      text = tools::Rd2txt(helpfile),
      html = tools::Rd2HTML(
        helpfile,
        package = "",
        stages = c("install", "render")
      ),
      latex = tools::Rd2latex(helpfile),
      Rd = tools:::prepare_Rd(helpfile)
    )
  )
  if (format == "html") {
    i <- grep("<body>", hs)
    j <- grep("</body>", hs)
    hs <- hs[(i+1):(j-1)]
  }
  hs <- c(before, hs, after)
  hs <- cat(hs, sep = "\n")
  invisible(hs)
}
```
- Help files can be accessed using “?function name” and contain examples of how to use the functions.
```{r install5, eval = FALSE}
?mmc.summary
```

```{r showhelp, echo = FALSE, results = "asis"}
help_console(mmc.summary, "QinR", format = "html")
```
## Introduction

Queueing theory is the mathematical study of the formation and function of queues.  A basic queueing system is a system where entities arrive at a facility requiring some service, they join a line, and wait for service from one or more servers. The results of queueing analysis can be used to offer faster customer service, increase traffic flow, improve order shipments from a warehouse, or to design data networks and call centers. In this first demonstration, we will use the random events of arrivals and service completions from a general distribution to demonstrate the development of a queue over time. We assume the reader has some previous knowledge of queueing networks. 

## Measures of System Performance

Variable | Definition
-------------------- | -------------
$\lambda$  | Average arrival rate
$S$  | Random service time
$\mu$  | Average service rate
$c$  | Number of servers
$r = \lambda / \mu$  | Offered load
$\rho = \lambda / c \mu$  | Traffic intensity or utilization
$T, T_{q}$  | Random time a customer spends in the system / queue
$W, W_{q}$  | Average time a customer spends in the system / queue
$N, N_{q}$  | Random number of customers in the system / queue
$L, L_{q}$  | Average number of customers in the system / queue

## Notation and relationships for G/G/1 queue

In event-oriented bookkeeping, the system state is only updated when events occur. Either when customers/jobs arrive or depart. Suppose we observe a system, recording the times of arrival and service for each entity. An alternative to recording arrival times is to record the time between arrivals. With this information we can calculate measures of performance (see table above) and find other bookkeeping results such as:

Variable | Definition | Sample relationship
------------- | ------------- | -------------
$A^{(n)}$  | Arrival time of cust. $n$ | 
$S^{(n)}$  | Service time of cust. $n$ |
$T^{(n)}$  | Inter. time cust. $n$ and $n+1$ | $T^{(n)} = A^{(n+1)} - A^{(n)}$
$U^{(n)}$  | Time cust. $n$ starts service | $U^{(n+1)} = max\{D^{(n)}, A^{(n+1)}\}$
$D^{(n)}$  |Departure time of cust. $n$ | $D^{(n)} = U^{(n)} + S^{(n)}$
$W_{q}^{(n)}$  | Time in queue of cust. $n$ | $W_{q}^{(n)} = U^{(n)} - A^{(n)}$
$W^{(n)}$  | Time in system of cust. $n$ | $W^{(n)} = W_{q}^{(n)} + S^{(n)}$

The analysis is obtained under the assumption of a single server with FCFS discipline. No assumptions are required on the probability laws for the interarrival times or service times. 

The gg1.summary() function takes three inputs. First an input of either the arrival times or the interarrival times, the service times, and a Boolean--set interarrival = TRUE if the first input is interarrival times. The function outputs a data frame with the bookkeeping values for each entity and a data frame which holds some performance measures.The user can access performance measures by name using the $ operator. Please see the examples that follow.

```{r gg1summary, echo=FALSE }
gg1.summary <- function(arrivals, service_times, interarrival = FALSE){
   if(length(arrivals) != length(service_times))
   {
      stop('Arrays must have equal length')
   }
   n <- length(arrivals)
   if(interarrival == TRUE){
      interarrival_times = c(arrivals, NA)
      service_times = c(NA, service_times)
      arrival_times = c(0)
      arrival_times <- append(arrival_times, interarrival_times[1])
      for(i in 2:n){
         arrival_times <- append(arrival_times, arrival_times[i] + interarrival_times[i])
      }
      starts_service <- c(NA, arrival_times[2])
      departure_times <- c(NA, service_times[2] + arrival_times[2])
      for(i in 3:(n+1)){
         starts_service <- append(starts_service, max(departure_times[i-1], arrival_times[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- c(starts_service - arrival_times)
      system_times <- c(queue_times + service_times)
      df <- data.frame(customers = c(0, seq(1:n)), arrival_times = arrival_times,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times, na.rm = TRUE)
      W <- mean(system_times, na.rm = TRUE)
      lambda <- n/departure_times[n+1]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
      
   }
   else{
      interarrival_times <- c(diff(arrivals), NA)
      starts_service <- c(0)
      departure_times <- c(service_times[1] - arrivals[1])
      for(i in 2:n){
         starts_service <- append(starts_service, max(departure_times[i-1], arrivals[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- starts_service - arrivals
      system_times <- queue_times + service_times
      df <- data.frame(customers = seq(1:n), arrivals = arrivals,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times)
      W <- mean(system_times)
      lambda <- n/departure_times[n]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
}
```

```{r ex1}
# Arrival times
arrival <- c(0, 2, 3, 6, 7, 8, 12, 14, 19, 20, 24, 26)
# Service times
service <- c(1, 3, 6, 2, 1, 1, 1, 2, 5, 1, 1, 3)
# Run gg1.summary() on this data
q <- gg1.summary(arrival, service)
# Use gt package for nice tables
library(gt)
# Get bookkeeping results
pt <- q$bookkeeping
pt %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))

```

<br />
Now suppose that we only had data on the interarrival times and the service times. 

```{r ex2}
# Interarrival times
inter <- c(1, 9, 6, 4, 7, 9, 5, 8, 4, 10, 6, 12, 6, 8, 
           9, 5, 7, 8, 8, 7)
# Service times
serv <- c(3, 7, 9, 9, 10, 4, 8, 5, 5, 3, 6, 3, 5, 4, 
          9, 9, 8, 6, 8, 3)
# Run gg1.summary() on this data
q2 <- gg1.summary(inter, serv, interarrival = TRUE)
pt2 <- q2$bookkeeping
pt2 %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt2 <- q2$res
qt2 %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))

```

## The Birth Death Process

Suppose you want to solve the flow balance equation for a birth-death type queue with finite capacity $n$. Given an array of arrival (birth) rates $\lambda = (\lambda_{0}, \lambda_{1}, \cdots)$ and an array of service (death) rates $\mu = (\mu_{1}, \mu_{2}, \cdots)$, the function BD.solve($\lambda$, $\mu$) will return $\{p_n, n \geq 0\}$, the discrete distribution of number of customers in system. Please see the following example with $\lambda = (3, 2, 1)$ and $\mu = (1, 2, 2)$.

```{r BD.solve, echo=FALSE }
BD.solve <- function(lambda, mu){
   if(length(lambda) != length(mu))
   {
      stop('Arrays must have equal length')
   }
   temp = lambda/mu
   k = length(lambda)
   s = 0
   for(j in 1:k){
      s = s + prod(temp[1:j])
   }
   p0 = 1/(1+s)
   pn = c(p0)
   for(j in 1:k){
      pn <- append(pn, temp[j]*pn[j])
   }
   return(pn)
}
```

```{r ex8}
mu <- c(1, 2, 2)
lambda <- c(3, 2, 1)

pn = BD.solve(lambda, mu)
print(pn)
```
Where the first element corresponds to $p_0$, the second to $p_1$, and so on. 

## M/M/c Markovian model

<br />
Next we consider an M/M/1 Markovian model. Given inputs arrival rate, service rate, and number of servers $c = 1$ the function mm1.summary() returns a data frame of performance measures for the queue and an array with the discrete distribution of number of customers in system. Additionally, by entering "plot_pn = TRUE", the function will plot this distribution. For m/m/1 queues, by entering "plot_waitSys = TRUE" the function will plot the probability density function of the waiting time in system and similarly "plot_waitQ = TRUE" will plot the probability density function of the waiting time in queue. The variable tol is the stopping criteria for finding the probability distribution of customers in the system. That is, the function stops finding additional probabilities when $\sum p_n < 1 - tol$. The user can access performance measures by name using the $ operator. Please consider the following example. 

```{r mm1summary, echo=FALSE }
mmc.summary <- function(lambda, mu, c, tol, 
                        plot_pn = FALSE,
                        plot_waitSys = FALSE,
                        plot_waitQ = FALSE){
   if(c == 1){
      rho = lambda/mu
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")
      }
   
      p_n = c()
      iter = 0
      while(sum(p_n) < (1-tol)){
         p_n = append(p_n, (rho^iter)*(1-rho))
         iter = iter + 1
      }
      if(plot_pn == TRUE){
         
         num_ent = c(0, 1:(length(p_n)-1))
         plot(num_ent, p_n, main="Distribution of Number of Customers in System",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      t = seq(1, 12*rho, by = 1)
      waitSys_probabilities = (mu - lambda)*exp(-(mu - lambda)*t)
      if(plot_waitSys == TRUE){
         plot(t, waitSys_probabilities, main="Waiting Time in System",
              xlab="Time Spent in System",
              ylab="Probability", pch = 19, col = "blue")
         lines(t, waitSys_probabilities, type = "b", col = "blue")
      }
      t = seq(1,12*rho, by = 1)
      waitQ_probabilities = c(1-rho, (mu*rho*(1-rho))*exp(-mu*(1 - rho)*t))
      if(plot_waitQ == TRUE){   
         plot(c(0, t), waitQ_probabilities, main= "Waiting Time in Queue",
              xlab="Time Spent in Queue",
              ylab="Probability", pch = 19, col = "blue")
         lines(t, (mu*rho*(1-rho))*exp(-mu*(1 - rho)*t), type = "b", col = "blue")
      }
      L = rho/(1-rho)
      L_q = rho^2/(1-rho)
      W = 1/(mu - lambda)
      W_q = lambda/(mu*(mu - lambda))
      U = 1 - p_n[1]
      I = 1 - rho
      
      rnames <- rbind("Utilization", 
                      "Idle time", "Mean time in system",
                      "Mean time in queue", "Mean number in system", "Mean number in queue")
      res <- data.frame(cbind(rnames, round(rbind(rho, I, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res, 
                  'rho' = rho, 'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q,
                  'prob_T' = waitSys_probabilities, 'prob_T_q' = waitQ_probabilities))
   }
   else{
      rho = lambda/(c*mu)
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")}
      # a := offered load
      a = lambda/mu
      # find p0
      l = 0
      for(n in 0:(c-1)){
         l <- l + (a^n)/(factorial(n))
      }
      r = (a^c)/(factorial(c)*(1-rho))
      p0 = 1/(l + r)
      # find pn
      p_n = c(p0)
      for(n in 1:c){
         p_n = append(p_n, ((a^n)/factorial(n))*p0)
      }
      
      iter = c+1
      while(sum(p_n) < (1-tol)){
         p_n = append(p_n, ((a^iter)/(factorial(c)*c^(iter-c)))*p0)
         iter = iter + 1
      }
      
      if(plot_pn == TRUE){
         num_ent = length(p_n)
         plot(c(1:num_ent-1), p_n, main="Distribution of Number of Customers in System",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      L_q = ((a^c)*rho/(factorial(c)*(1-rho)^2))*p0
      W_q = ((a^c)/(factorial(c)*(c*mu)*(1-rho)^2))*p0
      W = W_q + (1/mu)
      L = L_q + (lambda/mu)
      U = rho
      B = a
      I = p0
      delayed = ((a^c)*p0)/(factorial(c)*(1-rho))
      rnames <- rbind("Utilization", 
                      "Idle time", "Mean number busy servers", "Mean time in system",
                      "Mean time in queue", "Mean number in system", "Mean number in queue",
                      "Probability arriving entity waits in queue")
      res <- data.frame(cbind(rnames, round(rbind(U, I, B, W, W_q, L, L_q, delayed), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res,
                  'rho' = rho, 'p0' = I, 'r' = B, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
}
```

```{r ex3}
q <- mmc.summary(lambda = 4, mu = 4.4545, c = 1, 
                 tol = 0.01,
                 plot_pn = TRUE,
                 plot_waitQ = TRUE,
                 plot_waitSys = TRUE)

library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/1 Queues"))
```

<br />
Using the output we can find the probability that there are more than $k$ entities in the system using the formula $P(X \geq k) = \rho^{k}$. Suppose we wanted to find the probability that there are more than $k = 2$ entities in the system.

```{r ex4}
k = 2
prob_k_system <- (q$rho)^k
print(prob_k_system)
```

<br />
Recall that we can also find the following two probabilities. 
$$P(T > t) = e^{-\mu (1-\rho)t}$$
```{r ex5}
mu <- 4.4545
t <- 2
pr <- exp(-mu*(1 - q$rho)*t)
print(pr)
```

$$P(T_q > t) = \rho e^{-\mu (1-\rho)t}$$
```{r ex6}
mu <- 4.4545
t <- 2
pr2 <- (q$rho)*exp(-mu*(1 - q$rho)*t)
print(pr2)
```

<br />

Moving on, we consider Markovian queueing models with parallel channels: M/M/c/$\infty$/$\infty$ queues. 

```{r ex7}
q <- mmc.summary(lambda = 4, mu = 4.4545, c = 2, tol = 0.01, plot_pn = TRUE)

library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/c Queues"))
```

<br />

You may have noticed that we did not plot the probability density functions for waiting times in queue or waiting times in system for the m/m/c queue. Instead we will just demonstrate how to find the cumulative probability $P\{T_q \leq t\}$. 

$$P(T_q \leq t) = 1 - \dfrac{r^{c}p_{0}}{c!(1-\rho)} e^{-(c \mu - \lambda)t}$$
Where $r = \lambda / \mu$ and $\rho = \lambda / (c\mu)$. Then 
```{r ex9}
# given 
lambda <- 4
mu <- 4.4545
c <- 2
t <- 0.05

# performance results
rho <- q$rho
p0 <- q$p0
r <- q$r

pr <- 1 - ((r^c * p0)/(factorial(c)*(1 - rho)))*exp(-(c*mu - lambda)*t)
print(pr)
```

## Single-Server Finite Population Queue

```{r finitesummary, echo=FALSE}
########################################################################
# Finite Population Single Server Model (N >= 1)
########################################################################
# lambda := arrival rate
# mu := service rate
# N := system capacity
finitepopulation.summary <- function(lambda, mu, N){
   a <- lambda / mu
   if(N <= 100){
      bottleneck <- matrix(1, nrow = N+1, ncol = 1)
      for (n in 1:N) {
         bottleneck[n+1,1] <- bottleneck[n, 1]*(N-n+1)*a
      }
      p0 <- (1/sum(bottleneck))
      p_n <- c(bottleneck*p0)
      
      L_q <- N - ((lambda + mu)/lambda)*(1-p0)
      L <- N - (mu/lambda)*(1-p0)
      W <- N/(mu*(1-p0)) - 1/lambda
      W_q <- L_q/(lambda*(N-L))
      lambda_eff <- mu*(1-p0)
      I <- p0
      rnames <- rbind("Idle time", "Mean time in system",
                      "Mean time in queue", "Mean number in system", 
                      "Mean number in queue", "Effective arrival rate")
      res <- data.frame(cbind(rnames, round(rbind(I, W, W_q, L, L_q, lambda_eff), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res, 'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 
                  'L_q' = L_q, 'lambda_eff' = lambda_eff))
   }
   else{
      # 'Multiple Precision Floating-Point Reliably'
      # Pro: we can do this for very large N
      # Con: we have to depend on an external package that may change
      
      if("Rmpfr" %in% rownames(installed.packages()) == FALSE) {install.packages("Rmpfr")}
      suppressWarnings(suppressMessages(library(Rmpfr)))
      bottleneck <- mpfr(matrix(1, nrow = N+1, ncol = 1), 300)
      for (n in 1:N) {
         bottleneck[n+1,1] <- bottleneck[n, 1]*mpfr((N-n+1)*a, 300)
      }
      p0 <- (1/sum(bottleneck))
      p_n <- c(bottleneck*p0)
      p_n <- as.numeric(p_n)
      
      L_q <- as.numeric(N - ((lambda + mu)/lambda)*(1-p0))
      L <- as.numeric(N - (mu/lambda)*(1-p0))
      W <- as.numeric(N/(mu*(1-p0)) - 1/lambda)
      W_q <- as.numeric(L_q/(lambda*(N-L)))
      lambda_eff <- as.numeric(mu*(1-p0))
      I <- as.numeric(p0)
      rnames <- rbind("Idle time", "Mean time in system",
                      "Mean time in queue", "Mean number in system", 
                      "Mean number in queue", "Effective arrival rate")
      res <- data.frame(cbind(rnames, round(rbind(I, W, W_q, L, L_q, lambda_eff), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res,'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 
                  'L_q' = L_q, 'lambda_eff' = lambda_eff))
   }
}
```

Suppose we had a system where there is only one server and a finite population of $N$ customers which all have the same arrival rate $\lambda$. We can use the finitepopulation.summary() function. This function takes as inputs the arrival rate, the service rate, and the size of the finite population $N$. When $N$ is larger than 100, we employ the Rmpfr library which performs multiple-precision floating-point computations in an efficient way. The function will check if the user has this package installed. If not, it will install the package then load the library. 

<br />

Bare with us as we discuss the nice way we avoided calculating factorials in this function. For a finite population single-server model, we have that the probability that there are no customers in the system is

$$p_0 = \left[ \sum_{n = 0}^{N} \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} \right]^{-1}$$
When $n=0$, let
$$S_{0} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{0}}{N!} = 1$$
When $n=1$,

$$S_{1} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N(N-1)! \left(\dfrac{\lambda}{\mu}\right)^{1}}{(N-1)!} = N \left(\dfrac{\lambda}{\mu}\right)^{1} = S_{0} \cdot N \cdot \dfrac{\lambda}{\mu}$$

When $n=2$,

$$S_{2} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N(N-1)(N-2)! \left(\dfrac{\lambda}{\mu}\right)^{2}}{(N-2)!} = N(N-1) \left(\dfrac{\lambda}{\mu}\right)^{2} = S_{1} \cdot (N-1) \cdot \dfrac{\lambda}{\mu}$$
When $n=3$,

$$S_{3} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N(N-1)(N-2)(N-3)! \left(\dfrac{\lambda}{\mu}\right)^{3}}{(N-3)!} = N(N-1)(N-2) \left(\dfrac{\lambda}{\mu}\right)^{3} = S_{2} \cdot (N-2) \cdot \dfrac{\lambda}{\mu}$$

We continue on in this way, storing each value, using the previous one to calculate the next value up until the $N^{th}$ value. This will ultimately make up the sum that is used to calculate $p_0$. Then

$$p_{0} = \left[ \sum_{n=0}^{N} S_{n} \right]^{-1}$$
This value is then used to calculate all performance measures. Let's see an example for how the function works.

```{r finitesummaryex1}
lambda <- 0.025
mu <- 1
N <- 4
q <- finitepopulation.summary(lambda, mu, N)
pt <- q$res
pt %>%
   gt() %>%
   tab_header(
      title = md("Performance Measures for Single-Server Finite Population Queue"))
```

<br />

For $N > 100$, we avoid floating-point error.
```{r finitesummaryex2}
lambda <- 10
mu <- 5000
N <- 300
q <- finitepopulation.summary(lambda, mu, N)
pt <- q$res
pt %>%
   gt() %>%
   tab_header(
      title = md("Performance Measures for Single-Server Finite Population Queue"))

# See that this sum is equal to 1 :)
sum(q$pn)
```

## Open Single-Server Jackson Networks

Suppose we have an open Jackson network where entities may arrive from the outside at any node according to a Poisson process and entities are serviced according to an exponential distribution. There is no limit on queue capacity at any node and there is a probability, possibly nonzero, that an entity will leave the network at some node $i$ upon completion of service. We can use the function ojn.summary(R, gamma, mu, maxMarginalProb) to find performance measures for this system. This stands for 'Open Jackson Network Summary'. This function takes as inputs the routing matrix R, the mean arrival rate to each node gamma, the mean service rate of each node mu, and the max number of marginal probabilities you would like returned for each node. Please keep in mind that in order to avoid rounding error, it is necessary to keep the probabilities in the routing matrix as fractions if they are, for example, non-terminating, recurring decimal numbers. 
```{r ojn.summary, echo=FALSE}
ojn.summary <- function(R, gamma, mu, maxMarginalProb){
   n = nrow(R)
   m = ncol(R)
   K = length(mu)
   I = diag(x = 1, nrow = n, ncol = m)
   Q = I - R
   lambda_i = gamma%*%(solve(Q))
   rho_i = lambda_i / mu
   I_i = 1-rho_i
   Lq_i = (rho_i)^2 / I_i
   L_i = (rho_i)/ I_i
   W_i = L_i / lambda_i
   Wq_i = Lq_i / lambda_i
   L = sum(L_i)
   W = L/(sum(gamma))
   # find marginals
   p_n = matrix(0, maxMarginalProb, K)
   p_n[1,] = 1-rho_i
   for (i in 1:(maxMarginalProb-1)) {
      p_n[i+1,]=(rho_i^i)*(1-rho_i)
   }
   rnames <- rbind("Node i throughput", "Utilization at node i", 
                   "Probability node i is idle", "Mean time at node i","Mean number at node i",
                   "Mean queue time at node i", "Mean number in queue at node i")
   res <- data.frame(cbind(rnames, round(rbind(lambda_i, rho_i, I_i, W_i, L_i, Wq_i, Lq_i), 4)))
   names(res)<- c("Definition", sprintf("node%2d",seq(1:K)))
   return(list('marginal_probabilities' = p_n, 'res' = res,
               'throughput_i' = lambda_i, 'rho_i' = rho_i, 'idle' = I_i, 
               'W_i' = W_i, 'L_i' = L_i, 'Wq_i' = Wq_i, 'Lq_i' = Lq_i,
               'W' = W, 'L' = L))
}
```

```{r ex1 ojn}
R = matrix(c(0, 0.45, 0.55,
             0, 0, 0.02,
             0, 0.01, 0), 
           nrow = 3, ncol = 3, byrow = TRUE)
gamma = c(1, 5, 0)
mu = c(20, 10, 3)

q <- ojn.summary(R, gamma, mu, 15)

qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for Open Jackson Networks"))
q$marginal_probabilities

```

## Closed Single-Server Jackson Networks

In a closed Jackson network, there is no input rate from the outside world. Essentially, this is equivalent to a system where $N$ entities continuously travel inside the network. Suppose we have the following routing matrix and we need to solve $vR = v$ such that $\sum v_i = 1$. We can use the function solve.routing() to accomplish this. The only input necessary is the routing matrix. 
```{r solve routing matrix, echo=FALSE}
# find v given the routing matrix R
solve.routing <- function(R){
   n = nrow(R)
   m = ncol(R)
   I = diag(x = 1, nrow = n, ncol = m)
   Q = R - I
   Q = cbind(Q, rep(1, n))
   b = matrix(c(rep(0, n), 1), nrow = 1, ncol = (m+1))
   v = (b%*%t(Q))%*%solve(Q%*%t(Q))
}

```
```{r cjn ex 1}
# find v given the routing matrix
R = matrix(c(0, 0.75, 0.25,
             0.6666666667, 0, 0.3333333333, 
             1, 0, 0), nrow = 3, ncol = 3, byrow = TRUE)
v = solve.routing(R)
print(v)
```

Now, let's get the performance measures for each node in this network using the function cjn.summary(v, N, K, convolution = TRUE). This stands for 'Closed Jackson Network Summary'. The necessary inputs are v, the solution to $vR = v$ such that $\sum v_i = 1$, the given service rates, N the number of customers in the system, K the number of nodes in the network, and a boolean convolution. When convolution is set to true, the function uses Buzen's algorithm to solve for the summary statistics. Otherwise the function will use Mean Value Analysis. Using the same routing matrix as before let's see an example, first with convolution. 

```{r cjn, echo=FALSE}
# v := solution to vR = v
# N := number of customers in the network
# K := number of nodes
# if convolution = TRUE, uses convolution algorithm,
# else uses Mean Value Analysis.
cjn.summary <- function(v, mu, N, K, convolution = TRUE){
   if(convolution == TRUE){
      # Find tau_1, ..., tau_k
      tau = v/mu
      # Find G
      G = matrix(1, nrow = (N+1), ncol = K)
      for(i in 2:(N+1)){
         G[i, 1] = tau[1]^(i-1)
      }
      # i iterates over rows
      for(i in 2:(N+1)){
         # j iterates over columns
         for(j in 2:(K)){
            G[i, j] = G[i, j-1] + tau[j]*G[i-1, j]
         }
      }
      system_throughput = G[N,K]/G[(N+1), K]
      lambda_i = v*system_throughput
      rho_i = tau*system_throughput
      I_i = 1-rho_i
      # Find L_i, W_i
      p_bar = matrix(0, K, K)
      # iterates over n_i
      for(n_i in 1:N){
         # iterates over tau_i
         for(i in 1:K){
            p_bar[n_i, i] = (tau[i]^n_i)*(G[((N+1)-n_i),K]/G[(N+1), K])
         }
      }
      L_i = colSums(p_bar)
      W_i = L_i/lambda_i
      Lq_i = L_i - (lambda_i / mu)
      Wq_i = Lq_i / lambda_i
      p = matrix(0, N+1, K)
      # iterates over n_i
      for(n_i in 0:(N-1)){
         # iterates over tau_i
         for(i in 1:K){
            p[(n_i + 1), i] = (tau[i]^n_i)*((G[((N+1)-n_i),K] - tau[i]*G[((N+1)- n_i - 1),K])/G[(N+1), K])
         }
      }
      p[(N+1),] = (tau^N)/G[(N+1), K]
      
      
      rnames <- rbind("Node i throughput", "Utilization at node i", 
                      "Probability node i is idle", "Mean time at node i","Mean number at node i",
                      "Mean queue time at node i", "Mean number in queue at node i")
      res <- data.frame(cbind(rnames, round(rbind(lambda_i, rho_i, I_i, W_i, L_i, Wq_i, Lq_i), 4)))
      names(res)<- c("Definition", sprintf("node%2d",seq(1:K)))
      row.names(res) <- seq(1:7)
      return(list('marginal_probabilities' = p, 'res' = res, 'system_throughput' = system_throughput,
                  'lambda_i' = lambda_i, 'rho_i' = rho_i, 'idle' = I_i, 
                  'W_i' = W_i, 'L_i' = L_i, 'Lq_i' = Lq_i, 'Wq_i' = Wq_i))
   }
   ################################################################################
   # Mean Value Analysis algorithm
   else{
      # Find tau_1, ..., tau_k
      tau = v/mu
      # first row corresponds to L_{i}(0)
      # second to L_{i}(1) and so on
      L = matrix(0, N, K)
      # stores the W_{i}(n) values
      W = matrix(0, N, K)
      # stores the lambda(n) values
      lambda = rep(0, N)
      for(n in 1:N){
         if(n == 1){
            for(i in 1:K){
               W[n, i] = (1/mu[i])
            }
         }
         else{
            for(i in 1:K){
               W[n, i] = (1/mu[i])*(1 + L[n-1, i])
            }
         }
         lambda[n] = n/(sum(v*W[n,]))
         for(j in 1:K){
            L[n, j] = lambda[n]*v[j]*W[n, j]
         }
      }
      # Output at convergence:
      W_i = W[N,]
      L_i = L[N,]
      # Little's law : L = lambda * W
      # node i throughput
      lambda_i = L_i/W_i
      Lq_i = L_i - (lambda_i / mu)
      Wq_i = Lq_i / lambda_i
      # node i utilization
      rho_i = lambda_i / mu
      I_i = 1 - rho_i
      system_throughput = mean(rho_i/tau)
      rnames <- rbind("Node i throughput", "Utilization at node i", 
                      "Probability node i is idle", "Mean time at node i","Mean number at node i",
                      "Mean queue time at node i", "Mean number in queue at node i")
      res <- data.frame(cbind(rnames, round(rbind(lambda_i, rho_i, I_i, W_i, L_i,  Wq_i, Lq_i), 4)))
      names(res)<- c("Definition", sprintf("node%2d",seq(1:K)))
      row.names(res) <- seq(1:7)
      return(list('res' = res, 'system_throughput' = system_throughput,
                  'lambda_i' = lambda_i, 'rho_i' = rho_i, 'idle' = I_i, 
                  'W_i' = W_i, 'L_i' = L_i, 'Lq_i' = Lq_i, 'Wq_i' = Wq_i))
   }
}

```
```{r cjn ex 2}
# given service rates
mu = c(4, 1, 3)
# number of customers in the system
N = 3
# number of nodes in the network
K = 3

q <- cjn.summary(v, mu, N, K, convolution = TRUE)

qt <- q$res
      qt %>%
         gt() %>%
         tab_header(
            title = md("Measures of Performance for Closed Jackson Networks"))
# marginal distribution 
print(q$marginal_probabilities)
# system throughput
print(q$system_throughput)
      
```

Next we do this using the MVA algorithm. We recommend for the user to use convolution. For large systems it is more efficient and you can get the marginal distributions--whereas for this algorithm we do not include the marginal distributions. 

```{r cjn ex 3}
# using same inputs as above
q <- cjn.summary(v, mu, N, K, convolution = FALSE)

qt <- q$res
      qt %>%
         gt() %>%
         tab_header(
            title = md("Measures of Performance for Closed Jackson Networks"))
# system throughput
print(q$system_throughput)
      
```

<br />
